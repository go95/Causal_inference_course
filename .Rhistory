library(mvtnorm)
library(grf)
library(zeallot)
library(pbapply)
set.seed(1234)
n <- 1000
p <- 20 #this is just for compatability with bonus task
pi <- 0.5
X.test <- matrix(0, 101, p)
X.test[,1] <- seq(-2, 2, length.out = 101)
generate_data <- function() {
Sigma <- diag(p)
X <- rmvnorm(n, sigma = Sigma, method = "chol")
W <- rbinom(n=n,size = 1, prob = pi)
# generate  outcome variable
eps <- rnorm(n)
Y <- pmax(0, X[,1]) * W + X[,2] + pmax(0, X[,2]) + eps
return(list(Y = Y, W = W, X = X))
}
estimate_effect <- function(data, p){
tau.forest <- causal_forest(matrix(data$X[,1:p]), data$Y, data$W, num.trees = 4000)
tau.hat <- predict(tau.forest, X.test[,1:p], estimate.variance = TRUE)
sigma.hat <- sqrt(tau.hat$variance.estimates)
tau_hat <- tau.hat$predictions
CI <- c(tau.hat$predictions - qnorm(0.95) * sigma.hat, tau.hat$predictions + qnorm(0.95) * sigma.hat)
tau_true <- pmax(0,X.test[,1])
return(list(tau_true = tau_true, tau_hat = tau_hat, CI = CI))
}
squared_error <- function(estimates) {
se = (estimates$tau_true - estimates$tau_hat)^2
I <- estimates$tau_true >= estimates$CI[1] && estimates$tau_true <= estimates$CI[1]
return(c(se, I))
}
simulation_instance <- function(place_holder, p) {
data <- generate_data()
params <- estimate_effect(data, p)
return(squared_error(params))
}
simulation <- function(iterations, p) {
Z <- matrix(0, nrow = iterations, ncol=3)
Z <- pbapply(Z, 1, simulation_instance, p=p)
return(t(Z))
}
assess_simulation <- function() {
for (p in c(1, 3, 20)) {
result <- numeric()
op <- pboptions(type = "timer")
Z <- simulation(300, p)
pboptions(op)
means <- colMeans(Z)
plot(X.test[,1], result)
result <- rbind(result, means)
}
return(result)
}
result <- assess_simulation()
ะดั
ls
library(mvtnorm)
library(grf)
library(zeallot)
library(pbapply)
set.seed(1234)
n <- 1000
p <- 20 #this is just for compatability with bonus task
pi <- 0.5
X.test <- matrix(0, 101, p)
X.test[,1] <- seq(-2, 2, length.out = 101)
generate_data <- function() {
Sigma <- diag(p)
X <- rmvnorm(n, sigma = Sigma, method = "chol")
W <- rbinom(n=n,size = 1, prob = pi)
# generate  outcome variable
eps <- rnorm(n)
Y <- pmax(0, X[,1]) * W + X[,2] + pmax(0, X[,2]) + eps
return(list(Y = Y, W = W, X = X))
}
estimate_effect <- function(data, p){
tau.forest <- causal_forest(matrix(data$X[,1:p]), data$Y, data$W, num.trees = 4000)
tau.hat <- predict(tau.forest, X.test[,1:p], estimate.variance = TRUE)
sigma.hat <- sqrt(tau.hat$variance.estimates)
tau_hat <- tau.hat$predictions
CI <- c(tau.hat$predictions - qnorm(0.95) * sigma.hat, tau.hat$predictions + qnorm(0.95) * sigma.hat)
tau_true <- pmax(0,X.test[,1])
return(list(tau_true = tau_true, tau_hat = tau_hat, CI = CI))
}
squared_error <- function(estimates) {
se = (estimates$tau_true - estimates$tau_hat)^2
I <- estimates$tau_true >= estimates$CI[1] && estimates$tau_true <= estimates$CI[1]
return(c(se, I))
}
simulation_instance <- function(place_holder, p) {
data <- generate_data()
try(params <- estimate_effect(data, p))
return(squared_error(params))
}
simulation <- function(iterations, p) {
Z <- matrix(0, nrow = iterations, ncol=3)
Z <- pbapply(Z, 1, simulation_instance, p=p)
return(t(Z))
}
assess_simulation <- function() {
for (p in c(1, 3, 20)) {
result <- numeric()
op <- pboptions(type = "timer")
Z <- simulation(300, p)
pboptions(op)
means <- colMeans(Z)
plot(X.test[,1], result)
result <- rbind(result, means)
}
return(result)
}
result <- assess_simulation()
library(mvtnorm)
library(zeallot)
library(hdm)
library(balanceHD)
library(pbapply)
set.seed(1234)
n <- 100
p <- 500
rho <- 0.5
tau <- 0.5
beta_Y <-  1/(seq(1, p)^(2))
beta_Y <- beta_Y/norm(beta_Y, type = "2")
beta_W <- 1/(seq(1, p)^(1/2))
beta_W <- beta_W/norm(beta_W, type = "2")
generate_data <- function() {
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
theta <- X %*% beta_W + rnorm(n)
W <- rbinom(n, 1, 1/(1+exp(theta)))
epsilon <- rnorm(n)
Y <- tau*W + X %*% beta_Y + epsilon
return(list(Y = Y, X = X, W = W))
}
data <- generate_data()
c(Y, X, W) %<-% data
Eff <- rlassoEffect(X, Y, W, method = "double selection")
Eff
confinf(Eff)
confint(Eff)
residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
install.packages('Rmosek')
install.packages('Rmosek')
residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
library(mvtnorm)
library(zeallot)
library(hdm)
library(balanceHD)
library(pbapply)
set.seed(1234)
n <- 100
p <- 500
rho <- 0.5
tau <- 0.5
beta_Y <-  1/(seq(1, p)^(2))
beta_Y <- beta_Y/norm(beta_Y, type = "2")
beta_W <- 1/(seq(1, p)^(1/2))
beta_W <- beta_W/norm(beta_W, type = "2")
generate_data <- function() {
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
theta <- X %*% beta_W + rnorm(n)
W <- rbinom(n, 1, 1/(1+exp(theta)))
epsilon <- rnorm(n)
Y <- tau*W + X %*% beta_Y + epsilon
return(list(Y = Y, X = X, W = W))
}
estimate_effect <- function(data) {
c(Y, X, W) %<-% data
Eff <- rlassoEffect(X, Y, W, method = "double selection")
tau_dl <- coefficients(Eff)
tau_db <- residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
tau_simple <- mean(X[!W]) - mean(X[W])
return(list(tau_dl, tau_db, tau_simple, confint(Eff)))
}
squared_error <- function(params) {
return((params - tau)^2)
}
simulation_instance <- function(place_holder) {
data <- generate_data()
params <- estimate_effect(data)
return(squared_error(params))
}
simulation <- function(iterations) {
Z <- matrix(0, nrow = iterations, ncol=3)
Z <- pbapply(Z, 1, simulation_instance)
return(t(Z))
}
assess_simulation <- function() {
op <- pboptions(type = "timer")
Z <- simulation(400)
pboptions(op)
return(colMeans(Z))
}
data <- generate_data()
c(Y, X, W) %<-% data
Eff <- rlassoEffect(X, Y, W, method = "double selection")
tau_dl <- coefficients(Eff)
tau_db <- residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
data <- generate_data()
library(mvtnorm)
library(zeallot)
library(hdm)
library(balanceHD)
library(pbapply)
set.seed(1234)
n <- 100
p <- 500
rho <- 0.5
tau <- 0.5
beta_Y <-  1/(seq(1, p)^(2))
beta_Y <- beta_Y/norm(beta_Y, type = "2")
beta_W <- 1/(seq(1, p)^(1/2))
beta_W <- beta_W/norm(beta_W, type = "2")
generate_data <- function() {
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
theta <- X %*% beta_W + rnorm(n)
W <- rbinom(n, 1, 1/(1+exp(theta)))
epsilon <- rnorm(n)
Y <- tau*W + X %*% beta_Y + epsilon
return(list(Y = Y, X = X, W = W))
}
estimate_effect <- function(data) {
c(Y, X, W) %<-% data
Eff <- rlassoEffect(X, Y, W, method = "double selection")
tau_dl <- coefficients(Eff)
tau_db <- residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
tau_simple <- mean(X[!W]) - mean(X[W])
return(list(tau_dl, tau_db, tau_simple, confint(Eff)))
}
squared_error <- function(params) {
return((params - tau)^2)
}
simulation_instance <- function(place_holder) {
data <- generate_data()
params <- estimate_effect(data)
return(squared_error(params))
}
simulation <- function(iterations) {
Z <- matrix(0, nrow = iterations, ncol=3)
Z <- pbapply(Z, 1, simulation_instance)
return(t(Z))
}
assess_simulation <- function() {
op <- pboptions(type = "timer")
Z <- simulation(400)
pboptions(op)
return(colMeans(Z))
}
assess_simulation()
setwd("~/causal_inference")
setwd("~/Causal_inference_course")
library(mvtnorm)
library(zeallot)
library(crossEstimation)
library(pbapply)
set.seed(1234)
p <- 500
pi <- 0.5
rho <- 0.8
c_1 <- 1
c_0 <- 0
beta_1 <-  1/seq(1, p)
K = norm(beta_1, type = "2")/2
beta_1 <- beta_1/K
beta_0 <- rev(beta_1)
generate_data <- function(){
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
W <- rbinom(n = n, size = 1, prob = pi)
eps_0 <- rnorm(n)
Y0 <- c_0 + X %*% beta_0 + eps_0
eps_1 <- rnorm(n)
Y1 <- c_1 + X %*% beta_1 + eps_1
meanX <- colMeans(X)
tau_if <- c_1 - c_0 + meanX %*% (beta_1 - beta_0)
Y <- W * Y1 + (1-W) * Y0
return(list(data=list(Y=Y, W=W, X=X), tau_if=tau_if))
}
estimate_effect <- function(data){
c(dataset, tau_if) %<-% data
c(Y, W, X) %<-% dataset
## Simple estimator - difference in means
n_1 <- sum(W)
n_0 <- sum(1-W)
meanY1 <- (1/n_1) * sum(W*Y)
meanY0 <- (1/n_0) * sum((1-W) * Y)
tau_simple <- meanY1 - meanY0
# Variance of simple estimator
Var_simple <- (1/n_1^2) * sum(W * (Y - meanY1)^2) +
(1/n_0^2) * sum((1-W) * (Y - meanY0)^2)
#confidence interval 90%
upper_simple <- tau_simple + qnorm(p=1 - ((1 - 0.90)/2)) * sqrt(Var_simple)
lower_simple <- tau_simple - qnorm(p=1 - ((1 - 0.90)/2)) * sqrt(Var_simple)
ci_simple <- c(lower_simple, upper_simple)
#adjusted estimates
res <- ate.glmnet(X, Y, W, alpha = 1, conf.level = 0.9, nfolds = 10, method = "separate",
lambda.choice = "lambda.min")
return(c(tau_if, tau_simple, res$tau, ci_simple, res$conf.int))
}
evatuate_estimates <- function(estimates){
c(tau_if, tau_simple, tau_adj, ci_simple, ci_adj) %<-% estimates
se_1 <- (tau_if - tau_simple)^2
se_2 <- (tau_if - tau_adj)^2
I_1 <- tau_if >= ci_simple[1] && tau_if <= ci_simple[2]
I_2 <- tau_if >= ci_adj[1] && tau_if <= ci_adj[2]
return(c(se_1, se_2, I_1, I_2))
}
simulation_instance <- function(place_holder) {
data <- generate_data()
params <- estimate_effect(data)
return(evatuate_estimates(params))
}
simulation <- function(iterations) {
Z <- matrix(0, nrow = iterations, ncol=4)
Z <- pbapply(Z, 1, simulation_instance)
return(t(Z))
}
assess_simulation <- function() {
result <- numeric()
iterations <- c(50, 100, 300, 500, 1000)
for (it in iterations) {
op <- pboptions(type = "timer")
Z <- simulation(it)
pboptions(op)
result <- rbind(result, colMeans(Z))
}
return(result)
}
assess_simulation()
assess_simulation()
library(mvtnorm)
library(zeallot)
library(crossEstimation)
library(pbapply)
set.seed(1234)
p <- 500
pi <- 0.5
rho <- 0.8
c_1 <- 1
c_0 <- 0
beta_1 <-  1/seq(1, p)
K = norm(beta_1, type = "2")/2
beta_1 <- beta_1/K
beta_0 <- rev(beta_1)
generate_data <- function(){
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
W <- rbinom(n = n, size = 1, prob = pi)
eps_0 <- rnorm(n)
Y0 <- c_0 + X %*% beta_0 + eps_0
eps_1 <- rnorm(n)
Y1 <- c_1 + X %*% beta_1 + eps_1
meanX <- colMeans(X)
tau_if <- c_1 - c_0 + meanX %*% (beta_1 - beta_0)
Y <- W * Y1 + (1-W) * Y0
return(list(data=list(Y=Y, W=W, X=X), tau_if=tau_if))
}
estimate_effect <- function(data){
c(dataset, tau_if) %<-% data
c(Y, W, X) %<-% dataset
## Simple estimator - difference in means
n_1 <- sum(W)
n_0 <- sum(1-W)
meanY1 <- (1/n_1) * sum(W*Y)
meanY0 <- (1/n_0) * sum((1-W) * Y)
tau_simple <- meanY1 - meanY0
# Variance of simple estimator
Var_simple <- (1/n_1^2) * sum(W * (Y - meanY1)^2) +
(1/n_0^2) * sum((1-W) * (Y - meanY0)^2)
#confidence interval 90%
upper_simple <- tau_simple + qnorm(p=1 - ((1 - 0.90)/2)) * sqrt(Var_simple)
lower_simple <- tau_simple - qnorm(p=1 - ((1 - 0.90)/2)) * sqrt(Var_simple)
ci_simple <- c(lower_simple, upper_simple)
#adjusted estimates
res <- ate.glmnet(X, Y, W, alpha = 1, conf.level = 0.9, nfolds = 10, method = "separate",
lambda.choice = "lambda.min")
return(list(tau_if, tau_simple, res$tau, ci_simple, res$conf.int))
}
evatuate_estimates <- function(estimates){
c(tau_if, tau_simple, tau_adj, ci_simple, ci_adj) %<-% estimates
se_1 <- (tau_if - tau_simple)^2
se_2 <- (tau_if - tau_adj)^2
I_1 <- tau_if >= ci_simple[1] && tau_if <= ci_simple[2]
I_2 <- tau_if >= ci_adj[1] && tau_if <= ci_adj[2]
return(c(se_1, se_2, I_1, I_2))
}
simulation_instance <- function(place_holder) {
data <- generate_data()
params <- estimate_effect(data)
return(evatuate_estimates(params))
}
simulation <- function(iterations) {
Z <- matrix(0, nrow = iterations, ncol=4)
Z <- pbapply(Z, 1, simulation_instance)
return(t(Z))
}
assess_simulation <- function() {
result <- numeric()
iterations <- c(50, 100, 300, 500, 1000)
for (it in iterations) {
op <- pboptions(type = "timer")
Z <- simulation(it)
pboptions(op)
result <- rbind(result, colMeans(Z))
}
return(result)
}
assess_simulation()
library(mvtnorm)
library(zeallot)
library(hdm)
library(balanceHD)
library(pbapply)
set.seed(1234)
n <- 100
p <- 500
rho <- 0.5
tau <- 0.5
beta_Y <-  1/(seq(1, p)^(2))
beta_Y <- beta_Y/norm(beta_Y, type = "2")
beta_W <- 1/(seq(1, p)^(1/2))
beta_W <- beta_W/norm(beta_W, type = "2")
generate_data <- function() {
Sigma <- outer(1:p, 1:p, FUN=function(x, y) rho^(abs(x-y)))
X <- rmvnorm(n, sigma = Sigma, method = "chol")
theta <- X %*% beta_W + rnorm(n)
W <- rbinom(n, 1, 1/(1+exp(theta)))
epsilon <- rnorm(n)
Y <- tau*W + X %*% beta_Y + epsilon
return(list(Y = Y, X = X, W = W))
}
estimate_effect <- function(data) {
c(Y, X, W) %<-% data
Eff <- rlassoEffect(X, Y, W, method = "double selection")
tau_dl <- coefficients(Eff)
tau_db <- residualBalance.ate(X, Y, W, target.pop = 1,
fit.method = "elnet", alpha = 0.9, zeta = 0.5)
tau_simple <- mean(X[!W]) - mean(X[W])
return(c(tau_dl, tau_db, tau_simple))
}
squared_error <- function(params) {
return((params - tau)^2)
}
simulation_instance <- function(place_holder) {
data <- generate_data()
params <- estimate_effect(data)
return(squared_error(params))
}
simulation <- function(iterations) {
Z <- matrix(0, nrow = iterations, ncol=3)
Z <- pbapply(Z, 1, simulation_instance)
return(t(Z))
}
assess_simulation <- function() {
op <- pboptions(type = "timer")
Z <- simulation(400)
pboptions(op)
return(colMeans(Z))
}
assess_simulation()
